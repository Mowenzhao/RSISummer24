from Calc2D.CalculationClass import Calculation

import time
import numpy as np
from concurrent.futures import ThreadPoolExecutor
from tornado.ioloop import IOLoop
from tornado import gen
import tornado.web
import tornado.websocket
import os
import os.path
import json
import unicodedata
import logging
import base64
import traceback
import sys


import config

# threadpoolexecutor allows loops to be carried around in parallel
# here max_worker, i.e. number of parallel loops = 8
pool = ThreadPoolExecutor(max_workers=config.MAX_THREADPOOL_WORKERS)

###########################################################################
###########################################################################

def generate_redshifts(redshift_config):
                                                                              # what data type is redshift_config?
                                                                              # message(?) --> params --> redshift --> generate_redshift
    # logging.info sends confirmation for each received redshift
    # redshift_config is an array generated by input on the user interface
    logging.info(redshift_config)
    arrs = []
    for conf in redshift_config:
        # user input: whether the redshift is in logspace
        log = conf["log"]
        func = np.logspace if log else np.linspace
        start = np.log10(conf["from"]) if log else conf["from"]
        stop = np.log10(conf["to"]) if log else conf["to"]
        arrs.append(func(start, stop, conf["points"]))

        print("\nRedshifts: ")
        print(f'from: {conf["from"]}, to: {conf["to"]}, point: {conf["points"]}')

    # Remove duplicates
    # redshift_config eventually gives one single array, 
    # but different interval can have different rates
    return np.flip(np.unique(np.concatenate(arrs)), axis=0)
  
###########################################################################
###########################################################################

# Load available colormaps
def get_colormaps(path=config.COLORMAP_PATH):
    categories = []
    maps = []
    order = {'Default': 1, 'Uniform': 2, 'Diverging': 3, 'Miscellaneous': 4}

  # os.listdir lists all directories in the specified path
  # os.path.join('folder1', 'folder2', 'file') gives folder1\folder2\file
  # sorted(<item>, key = lambda d: order[d]); 'd' stands for directory name
  # sorting directory names according to the order dictionary
    cmap_directories = list(sorted(
        os.listdir(os.path.join("static", path)),
        key=lambda d: order[d]
        ))

    print("cmap_directories: ", cmap_directories)
  
    for directory in cmap_directories:
        categories.append(directory)
        maps_for_category = []
        for cmap in os.listdir(os.path.join("static", path, directory)):
            maps_for_category.append({
              # rfind returns the index that contains a period
              # cmaps[:<index>] then slices the directory up to that index
                'label': cmap[:cmap.rfind(".")],
              # config being a set of predefined values
                'src': os.path.join(os.path.join(config.COLORMAP_PATH, directory, cmap)),
                })
        maps.append(maps_for_category)
    print("categories: ", categories, "\n")
    print("maps: ", maps, "\n")
    return categories, maps
  
######################################################################
                                                                      # web request with tornado: different classes, each inheriting
                                                                      # tornado.web.RequestHandler(for one time data) or
                                                                      # websocket.webSocketHandler(for persistent communications)
                                                                      # application (in __main__) will then put it all together

                                                                      # server (backend) is handled with python (here and Calc2D)
                                                                      # client (frontend) is handled with:
                                                                          # html (in templates) for webpage structure
                                                                          # javascript (.js) (found w html and in static) for dynamics
                                                                          # css (cascading style sheet) (in static) for styles

#########################################################################

class SimulationHandler(tornado.web.RequestHandler):
  # custom request handler class for handling web requests.
  # service provided by Tornado, hence the name
    def get(self): # self refers to an instance created in class SimulationHandler
        #input("getting SimulationHandler; Press Enter")
        print("\nget_colormaps(): ") 
        categories, colormaps = get_colormaps()
        self.render('RSI.html', categories=categories, colormaps=colormaps)
      # self.render fills in the categories and colormaps into the html template RSI.html
      # RSI.html defined in the folder "templates"

###########################################################################
###########################################################################


################################################################### code structure: 
                                                                            # websockethandler functions: open, on_close, and on_message 
                                                                                    # (three different cases of on_message); 
                                                                            # RSI physics specific functions used in on_message

class DataConnection(tornado.websocket.WebSocketHandler):
  # websockethandler allows two-way communication between backend python code and website inputs
  # WedSocketHandler: 
        # open(self), on_close(self), on_message(self, message), etc.
        # each function handles a part of the communication and reports a message in console
    def open(self):
        input("opening data connection; Press Enter")
        logging.info("Client connected!")
        self.calc = Calculation(kbins=config.TRANSFER_FUNCTION_CLIENT_SAMPLES)
      # Calculation class from Calc2d/CalculationClass.py, which calls the CLASS program
      
        # Send list of `k` values only once
        logging.info("Sending k range to client");
      # self.write_message writes message (data) to client (server), while logging.info writes to console
      
        self.write_message(json.dumps({
            "type": "krange",
            "k": self.calc.krange.tolist(),
            }))
      # json.dumps converts a python dictionary to a JSON string, and the JSON string sent to server
      # "k": self.calc.krange.tolist() syntax:
          # calc: instance of Calculation class
          # krange: attribute of Calculation class, defined elsewhere
          # tolist(): convert to list from numpy array

    def on_close(self):
        logging.info("Connection was closed")

    @gen.coroutine  # used to mark the following function as a coroutine (a function that can pause and resume its execution)
    ### TRY REMOVING THE ABOVE

    def on_message(self, message):
        message = json.loads(message)
        # message is typed below by the logging.debug function
      
        param_type = message['type']
      
        logging.debug("Received message from client: {}".format(message))
        # logging.debug or logging.info print messages on console for the developer to see
        # no difference in functionality

        # Params has three types: "Initial"(initial condition), "Cosmo"(cosmological parameters), and "Start" (dk what it is)
        params = message['params']      

        ############ example message:  
        ### {'type': 'Initial', 
        ###  'params': {'xScale': 400, 
        ###             'resolution': 200, 
        ###             'initialDataType': 'SI', 
        ###             'sigma': 10, 
        ###             'SILimit': 'None', 
        ###             'n_s': 0.96, 
        ###             'redshift': [{'from': 1000000, 'to': 1089, 'points': 60, 'log': True}, {'from': 1089, 'to': 0.01, 'points': 40, 'log': True}]}}

        if param_type == "Initial":
            input("\nBelow shows the function of Initial param type. Press Enter to continue\n")
            initialDataType = str(params['initialDataType'])

            # user-input initial condition got feed into CLASS
            size = params["xScale"]
            resolution = int(params["resolution"])
            self.calc.resolution = resolution
            self.calc.size = size

            logging.info("Size: {} x {} Mpc^2, resolution: {} x {}".format(size, size, resolution, resolution))

            SIlimit = params['SILimit']      
            print("SIlimit: ", SIlimit)
          
            if SIlimit == "None":
                SIlimit = None

            sigma = float(params['sigma']) 
            print("sigma: ", sigma)
          
            SI_ns = params['n_s']
            if initialDataType == "SI":        
                A_s = 2.214 * 10**(-9)
            else:
                A_s = 1                        
            print("SI_ns: ", SI_ns)
          
            # No need to print, already printed in generate_redshifts function defined above
            redshift = generate_redshifts(params["redshift"])
          
            self.calc.redshift = redshift

            self.write_message(
                json.dumps({
                    'type': 'redshift',
                    'redshift': redshift.tolist()
                }))

            logging.info("Submitting initial state generation to ThreadPoolExecutor")
          
          # yield: suggests the code is a part of a coroutine. "yield" pauses the function until the result is ready
          # set_initial_condition, defined below
            yield pool.submit(self.set_initial_condition, sigma, initialDataType,
                              SIlimit, SI_ns, A_s)
            self.send_initial_state()  ####### defined below
            self.write_message(json.dumps({'type': 'success', 'sort': 'Initial'}))
          # self.write_message updates the data on the user end

        elif param_type == "Cosmo":
            input("\nBelow shows the function of Cosmo param type. Press Enter to continue\n")
            logging.info("Received cosmological parameters")
            cosmological_parameters = params
          
            print("cosmological_parameters: \n", cosmological_parameters, "\n")
          
            logging.info("Submitting calculation to ThreadPoolExecutor")

            # yield: suggests the code is a part of a coroutine. "yield" pauses the function until the result is ready
            # self.set_cosmological_parameters: defined below
            messages = yield pool.submit(self.set_cosmological_parameters, cosmological_parameters)
            for message in messages:
                self.write_message(json.dumps(message))
              
        elif param_type == "Start":
            input("\nBelow shows the function of Start param type. Press Enter to continue\n")
            logging.info("Starting propagation...")
            try:
                for redindex, z in enumerate(self.calc.redshift):
                  # send_frame defined below
                    self.send_frame(redindex)
                self.write_message(json.dumps({'type': 'success', 'sort': 'Data'}))
            except Exception as e:
                logging.exception(e)
                self.send_exception(e)

  # send_frame: 
  # 1. receives redshift information
  # 2. Send data to calculation each time iteration
  # 3. Send data to user-end each time iteration
  
    def send_frame(self, redindex):
        # `extrema`: (minimum, maximum) of (real space) data
        Valuenew, FValuenew, extrema = self.calc.getData(redindex)  
        logging.info("Sending data for redshift = {}".format(self.calc.redshift[redindex]))

      # Create data to be displayed in transfer function window
      # calc.getTransferData, defined in calc class, gets called for each time iteration
        TransferData, _ = self.calc.getTransferData(redindex)

        self.write_message(json.dumps({'type': 'extrema', 'extrema': extrema}))
        progress = float(redindex) / len(self.calc.redshift)

      # convert binary data to base64 to be calculated
        real = {quantity: base64.b64encode(data.astype(np.float32)).decode() for quantity, data in Valuenew.items()}
        transfer = {quantity: base64.b64encode(data.astype(np.float32)).decode() for quantity, data in TransferData.items()}

      # Data sent to user-end each time iteration: Updating progress bar.
        self.write_message(
            json.dumps({
                'type': 'data',
                'progress': progress,
                'real': real,
                'fourier': [],
                'transfer': transfer,
            }))

  # send_initial_state: ##################################################### 
  # Similarly, send input values to calculation, the result of which then generate the display on the user interface
  # display: graph for transfer function and initial density map.
    def send_initial_state(self):
        Value, FValue, extrema = self.calc.getInitialData()
        TransferData = np.ones(config.TRANSFER_FUNCTION_CLIENT_SAMPLES)
        krange = np.zeros(config.TRANSFER_FUNCTION_CLIENT_SAMPLES)
        logging.info("Sending initial data to client.")
        self.write_message({
            "type": "resolution",
            "value": self.calc.resolution
            })
        extremastring = json.dumps({'type': 'extrema', 'extrema': extrema})
        datastring = json.dumps({
            'type': 'data',
            # 'real': base64.b64encode(Value.astype(np.float32)),
            'real': base64.b64encode(Value.astype(np.float32)).decode(),
            'fourier': [],
            # 'transfer': base64.b64encode(TransferData.astype(np.float32)),
            'transfer': base64.b64encode(TransferData.astype(np.float32)).decode(),
            'k': krange.tolist()
            })
        self.write_message(extremastring)
        self.write_message(datastring)

 # gets called before send_initial_state.
  # Just to send to fill parameters. No message sent back to user
    def set_initial_condition(self, sigma, initialDataType, SIlimit, SI_ns, A_s):
        try:
            self.calc.setInitialConditions(
                sigma=sigma,
                initialDataType=initialDataType,
                SIlimit=SIlimit,
                SI_ns=SI_ns,
                A=A_s
                )
        except Exception as e:
            logging.exception(e)
            self.send_exception(e)

    def send_exception(self, e):
        self.write_message(json.dumps({'type': 'exception', 'exception': traceback.format_exc()}))

  # set_cosmological parameters
  # 1. sending cosmo parameters to calculations
  # 2. sending calculations result to get the graph. 
    def set_cosmological_parameters(self, cosmologicalParameters):
        input("\nset_cosmological_parameters. Press Enter to Continue: \n")
        try:
            messages = []
            logging.info("Starting calculation...")
            self.calc.setCosmologialParameters(cosmologicalParameters=cosmologicalParameters)
            logging.info("Finished calculation!")

          # in writing messages, result from CLASS are calculated and extracted
          # When the three are calculated and appened, is when the last two (probably three) graphs appear.
          
            messages.append({'type': 'success', 'sort': 'Cosmo'})
          
            input("\nappend Cl")
            messages.append({
                'type': 'Cl',
                'l': self.calc.tCl.l.tolist(),
                'tCl': self.calc.tCl.tCl.tolist()
                })
          
            input("\nappend mPk")
            messages.append({
                'type': 'mPk',
                'kh': self.calc.mPk.kh.tolist(),
                'Pkh': self.calc.mPk.Pkh.tolist()
                })

          # Calculating frames of decoupling
            z_of_decoupling = self.calc.z_dec
            frame_of_decoupling = np.argmin(np.abs(z_of_decoupling - self.calc.redshift))
          # integer conversion due to the python update
            frame_of_decoupling = int(frame_of_decoupling)
            if self.calc.redshift[frame_of_decoupling] > z_of_decoupling:
                frame_of_decoupling -= 1

            input("\nappend decoupling")
            messages.append({
                'type': 'decoupling',
                'frame': frame_of_decoupling,
                'z': z_of_decoupling})
          
        except Exception as e:
            logging.exception(e)
            self.send_exception(e)
        else:
            return messages


def main():
    logging.getLogger().setLevel(logging.DEBUG)

    application = tornado.web.Application(
        [
            (r"/", SimulationHandler),
            (r"/datasocket", DataConnection),
        ],
        template_path=os.path.join(os.path.dirname(__file__), "templates"),
        static_path=os.path.join(os.path.dirname(__file__), "static"),
        debug=True,
    )

    PORT = config.PORT if len(sys.argv) == 1 else int(sys.argv[1])
    application.listen(PORT)
    logging.info("Application launched on http://localhost:{}".format(PORT))
    logging.info("Use a different location by passing a different port number, e.g. python tornadoserver.py 1234")
    IOLoop.instance().current().start()


if __name__ == '__main__':
    main()
